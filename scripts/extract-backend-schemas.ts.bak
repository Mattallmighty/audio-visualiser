#!/usr/bin/env tsx
/**
 * Backend Schema Extractor
 * 
 * Fetches LedFx backend Python effect files from GitHub and generates
 * TypeScript schemas, defaults, and mappings for WebGL visualizers.
 * 
 * This ensures frontend WebGL configs stay in sync with backend definitions.
 * 
 * Run: pnpm generate:backend
 */

import fs from 'fs-extra'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const OUTPUT_DIR = path.join(__dirname, '../src/webgl/generated')
const GITHUB_RAW_BASE = 'https://raw.githubusercontent.com/LedFx/LedFx/main/ledfx/effects'

// Mapping of frontend WebGL visualizer names to backend effect files
const WEBGL_EFFECTS = {
  // Matrix effects
  plasma2d: 'plasma2d.py',
  flame: 'flame2d.py',
  gameoflife: 'game_of_life.py',
  digitalrain: 'digitalrain2d.py',
  equalizer2d: 'equalizer2d.py',
  noise2d: 'noise2d.py',
  blender: 'blender.py',
  clone: 'clone.py',
  bands: 'bands.py',
  bandsmatrix: 'bands_matrix.py',
  blocks: 'blocks.py',
  keybeat2d: 'keybeat2d.py',
  texter: 'texter2d.py',
  plasmawled2d: 'plasmawled.py',
  radial: 'radial.py',
  soap: 'soap2d.py',
  waterfall: 'waterfall2d.py',
  
  // 3D effects
  gif: 'gifplayer.py',
  bleep: 'bleep.py',
  concentric: 'concentric.py',
  image: 'imagespin.py',
  
  // Additional effects (assuming filesystem shader effects)
  bars3d: null,        // Pure frontend shader
  particles: null,     // Pure frontend shader
  waveform3d: null,    // Pure frontend shader
  radial3d: null,      // Pure frontend shader
  matrix: null,        // Pure frontend shader
  terrain: null,       // Pure frontend shader
  geometric: null,     // Pure frontend shader
} as const

interface SchemaField {
  id: string
  title: string
  type: 'string' | 'number' | 'integer' | 'boolean' | 'color'
  description?: string
  default?: any
  min?: number
  max?: number
  step?: number
  enum?: string[]
  gradient?: boolean
}

interface EffectSchema {
  name: string
  fields: SchemaField[]
  hiddenKeys: string[]
  advancedKeys: string[]
  defaults: Record<string, any>
}

/**
 * Fetch file content from GitHub
 */
async function fetchGitHubFile(filepath: string): Promise<string> {
  const url = `${GITHUB_RAW_BASE}/${filepath}`
  console.log(`Fetching: ${url}`)
  
  try {
    const response = await fetch(url)
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }
    return await response.text()
  } catch (error) {
    console.error(`Failed to fetch ${filepath}:`, error)
    throw error
  }
}

/**
 * Parse Python effect file and extract schema information
 */
function parsePythonEffect(content: string, effectName: string): EffectSchema {
  const fields: SchemaField[] = []
  const defaults: Record<string, any> = {}
  let hiddenKeys: string[] = []
  let advancedKeys: string[] = []

  // Extract HIDDEN_KEYS
  const hiddenKeysMatch = content.match(/HIDDEN_KEYS\s*=\s*.*?\[([^\]]+)\]/s)
  if (hiddenKeysMatch) {
    hiddenKeys = hiddenKeysMatch[1]
      .split(',')
      .map(k => k.trim().replace(/['"]/g, ''))
      .filter(k => k && k !== '...')
  }

  // Extract ADVANCED_KEYS
  const advancedKeysMatch = content.match(/ADVANCED_KEYS\s*=\s*.*?\[([^\]]+)\]/s)
  if (advancedKeysMatch) {
    advancedKeys = advancedKeysMatch[1]
      .split(',')
      .map(k => k.trim().replace(/['"]/g, ''))
      .filter(k => k && k !== '...')
  }

  // Extract CONFIG_SCHEMA fields
  // Match vol.Optional blocks
  const optionalRegex = /vol\.Optional\s*\(\s*["']([^"']+)["']\s*,\s*description\s*=\s*["']([^"']*)["']\s*(?:,\s*default\s*=\s*([^)]+))?\s*\)\s*:\s*([^,]+)/gs

  let match
  while ((match = optionalRegex.exec(content)) !== null) {
    const [, id, description, defaultValue, validator] = match
    
    // Parse validator to determine type and constraints
    const field = parseValidator(id, description, defaultValue, validator.trim())
    if (field) {
      fields.push(field)
      defaults[id] = field.default
    }
  }

  // Add developer_mode if not present (common to all effects)
  if (!fields.find(f => f.id === 'developer_mode')) {
    fields.push({
      id: 'developer_mode',
      title: 'Developer Mode',
      type: 'boolean',
      default: false
    })
    defaults.developer_mode = false
  }

  return {
    name: effectName,
    fields,
    hiddenKeys,
    advancedKeys,
    defaults
  }
}

/**
 * Parse voluptuous validator to determine field type and constraints
 */
function parseValidator(id: string, description: string, defaultValue: string | undefined, validator: string): SchemaField | null {
  const field: SchemaField = {
    id,
    title: id.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
    type: 'string',
    description
  }

  // Parse default value - clean up trailing commas and whitespace
  if (defaultValue) {
    defaultValue = defaultValue.trim().replace(/,$/, '').trim()
    
    if (defaultValue === 'True') {
      field.default = true
    } else if (defaultValue === 'False') {
      field.default = false
    } else if (defaultValue.startsWith('"') || defaultValue.startsWith("'")) {
      field.default = defaultValue.slice(1, -1)
    } else if (!isNaN(Number(defaultValue)) && defaultValue !== '') {
      field.default = Number(defaultValue)
    } else if (defaultValue.startsWith('#')) {
      // Color hex value
      field.default = defaultValue
    } else if (defaultValue.includes('.value')) {
      // Enum reference like HealthOptions.ALL.value - extract the enum name
      const enumMatch = defaultValue.match(/\.([A-Z]+)\.value/)
      field.default = enumMatch ? enumMatch[1].toLowerCase() : defaultValue
    } else {
      // Keep as string, strip quotes if present
      field.default = defaultValue.replace(/^["']|["']$/g, '')
    }
  }

  // Parse validator type
  if (validator === 'bool') {
    field.type = 'boolean'
    field.default = field.default ?? false
  } else if (validator.includes('validate_color')) {
    field.type = 'color'
    field.gradient = false
    field.default = field.default ?? '#000000'
  } else if (validator.includes('validate_gradient')) {
    field.type = 'color'
    field.gradient = true
  } else if (validator.includes('vol.In')) {
    // Enum type
    field.type = 'string'
    // Could extract enum values but complex - leave as string for now
  } else if (validator.includes('vol.Coerce(float)') || validator.includes('vol.Coerce(int)')) {
    // Number type with range
    field.type = validator.includes('vol.Coerce(int)') ? 'integer' : 'number'
    
    const rangeMatch = validator.match(/vol\.Range\s*\(\s*min\s*=\s*([^,\s)]+)(?:\s*,\s*max\s*=\s*([^,\s)]+))?\s*\)/)
    if (rangeMatch) {
      field.min = Number(rangeMatch[1])
      if (rangeMatch[2]) {
        field.max = Number(rangeMatch[2])
      }
      
      // Calculate step based on range and type
      if (field.type === 'integer') {
        field.step = 1
      } else {
        const range = (field.max ?? 10) - (field.min ?? 0)
        field.step = range > 10 ? 1 : range > 1 ? 0.1 : 0.01
      }
    }
    
    // Ensure default is a number
    if (typeof field.default === 'string') {
      field.default = Number(field.default) || (field.min ?? 0)
    }
    field.default = field.default ?? (field.min ?? 0)
  }

  return field
}

/**
 * Generate TypeScript schema definitions file
 */
function generateSchemasFile(schemas: Record<string, EffectSchema>): string {
  let output = `/**
 * WebGL Visualizer UI Schemas (Generated from Backend)
 * 
 * ‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated from: https://github.com/LedFx/LedFx/tree/main/ledfx/effects
 * 
 * Run \`pnpm generate:backend\` to regenerate.
 */

export const VISUALISER_SCHEMAS: Record<string, any[]> = {\n`

  for (const [key, schema] of Object.entries(schemas)) {
    output += `  ${key}: [\n`
    
    for (const field of schema.fields) {
      output += `    {\n`
      output += `      id: '${field.id}',\n`
      output += `      title: '${field.title}',\n`
      output += `      type: '${field.type}'`
      
      if (field.description) {
        output += `,\n      description: '${field.description}'`
      }
      if (field.min !== undefined) {
        output += `,\n      min: ${field.min}`
      }
      if (field.max !== undefined) {
        output += `,\n      max: ${field.max}`
      }
      if (field.step !== undefined) {
        output += `,\n      step: ${field.step}`
      }
      if (field.enum) {
        output += `,\n      enum: ${JSON.stringify(field.enum)}`
      }
      if (field.gradient !== undefined) {
        output += `,\n      gradient: ${field.gradient}`
      }
      
      output += `\n    },\n`
    }
    
    output += `  ],\n`
  }

  output += `}\n`
  return output
}

/**
 * Generate TypeScript defaults file
 */
function generateDefaultsFile(schemas: Record<string, EffectSchema>): string {
  let output = `/**
 * WebGL Visualizer Default Configurations (Generated from Backend)
 * 
 * ‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated from: https://github.com/LedFx/LedFx/tree/main/ledfx/effects
 * 
 * Run \`pnpm generate:backend\` to regenerate.
 */

export const DEFAULT_CONFIGS: Record<string, any> = {\n`

  for (const [key, schema] of Object.entries(schemas)) {
    output += `  ${key}: ${JSON.stringify(schema.defaults, null, 2).replace(/\n/g, '\n  ')},\n`
  }

  output += `}\n`
  return output
}

/**
 * Generate backend mapping file
 * Now dynamically generated - effect names match backend filenames
 */
function generateBackendMappingFile(schemas: Record<string, EffectSchema>): string {
  // Generate mapping where keys match backend filenames (without .py)
  const backendMapping: Record<string, string> = {}
  
  for (const effectName of Object.keys(schemas)) {
    // Effect name IS the backend name (no transformation needed)
    backendMapping[effectName] = effectName
  }

  let output = `/**
 * WebGL to Backend Effect Mapping (Generated)
 * 
 * ‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated from: https://github.com/LedFx/LedFx/tree/main/ledfx/effects
 * 
 * This mapping is now 1:1 since frontend effect names match backend filenames.
 * Run \`pnpm generate:backend\` to regenerate.
 */

export const VISUAL_TO_BACKEND_EFFECT: Record<string, string> = ${JSON.stringify(backendMapping, null, 2)}
`

  return output
}

/**
 * Main execution
 */
async function main() {
  console.log('üîÑ Extracting schemas from LedFx backend...\n')

  fs.ensureDirSync(OUTPUT_DIR)
  
  const schemas: Record<string, EffectSchema> = {}

  // Fetch and parse each effect
  for (const [effectName, filename] of Object.entries(WEBGL_EFFECTS)) {
    if (!filename) {
      console.log(`‚è≠Ô∏è  Skipping ${effectName} (frontend-only shader)`)
      continue
    }

    try {
      const content = await fetchGitHubFile(filename)
      const schema = parsePythonEffect(content, effectName)
      schemas[effectName] = schema
      console.log(`‚úÖ Parsed ${effectName}`)
    } catch (error) {
      console.error(`‚ùå Failed to process ${effectName}:`, error)
      // Continue with other effects
    }
  }

  // Generate TypeScript files
  console.log('\nüìù Generating TypeScript files...')
  
  const schemasContent = generateSchemasFile(schemas)
  const defaultsContent = generateDefaultsFile(schemas)
  const mappingContent = generateBackendMappingFile(schemas)

  await fs.writeFile(path.join(OUTPUT_DIR, 'schemas.ts'), schemasContent)
  await fs.writeFile(path.join(OUTPUT_DIR, 'defaults.ts'), defaultsContent)
  await fs.writeFile(path.join(OUTPUT_DIR, 'backend-mapping.ts'), mappingContent)

  console.log(`\n‚ú® Generated ${Object.keys(schemas).length} effect schemas`)
  console.log(`   Output: ${path.relative(process.cwd(), OUTPUT_DIR)}`)
  console.log('\nüéâ Backend schema extraction complete!')
}

main().catch(error => {
  console.error('Fatal error:', error)
  process.exit(1)
})
